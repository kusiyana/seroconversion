		# * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
		
		#               this file processes linear mixed model (LMM) data generated by SAS and calculates the mean window period.
		#               NB this variant of the script keeps OD constant and varies the cut off time in which OD is considered.
		#               means are stored in "mean" list, ie mean[[j]], where j corresponds to index in "names" array.
		
		# * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 

		# settings
		fileReadLocation = "C:/Documents and Settings/heastwood/My Documents/SACEMA/OD cut-off/harg-22-10/"
		fileName = "C:/Documents and Settings/heastwood/My Documents/SACEMA/OD cut-off/hargrove-OD-22.10.2010.csv" # hargrove BED data location
		ODL <- 0.0476
		fileFixedArray <- "LMM_28.7_OUT_var_OD__const_S.4_TL.0_TU.120_EASF.ENST_COV.1.out" #EASF.ENST
		fileRandomArray <- "LMM_28.7_OUT_var_OD__const_S.4_TL.0_TU.120_EASF.ENST_COV.1"
		ODL <- 0.0476 # for the LMM equation
		Wmax <- 365

		# <-------------------------------------------------Functions ----------------------------------------------------------------------------------------->
	
		# boot strap
		bootMean <- function (data=window.elk[,3],B=1000,alpha=c(0.025,0.975)) {
		library(bootstrap)
		n <- length(data)
		theta <- mean(data)
		stddev <- sqrt(var(data))
		boot.theta <- numeric(B)
		for(i in 1:B){
			boot.data <- data[sample(1:n,replace=TRUE)]
			boot.theta[i] <- mean(boot.data)
		}
				
		#BCa
		BCa <-bcanon(data,nboot=B,theta=function(x)mean(x),alpha=alpha)$confpoint[,2]
		leng.BCa <- max(BCa)-min(BCa)
		vorm.BCa <- (max(BCa)-theta)/(theta-min(BCa))
		
		bootdev = 	(BCa[1]- mean(boot.theta))/(-1.96)
		
		#lower, upper, bootmean, mean
		return (c(BCa[1], BCa[2],mean(boot.theta),theta, bootdev))
	}
	
	
		# <-------------------------------------------------End functions ----------------------------------------------------------------------------------------->
	
	#create different OD cutof scenarios and store in list
	Sdata <- list(); tempDiffY365sp <- list(); surv <- list(); avg <- list(); mean <- list(); var <- list();tempDiffY365 <- list()
	CI <- list(); CIsp <- list(); sasOut <- list(); upper <- list(); lower <- list();SD = list();  addonArrayList = list()
	CoeffVar=list();tempDiff=list(); count365=list(); bothN <- list(); lenArray <- list()
	
	colours = c("red","blue","green","yellow","black","purple", "cyan","magenta", "orange", "pink", "brown", "violet")
	limitArray = array(); CIout = array(); CIoutsp <- array();
	fixedArray <- read.table(file = paste(fileReadLocation, fileFixedArray, sep=""), head=TRUE, sep=",")
	namesArray <- read.table(file = paste(fileReadLocation, fileRandomArray, ".names", sep=""), head=FALSE, sep=",")
	loopStart <- 1
	loopLimit <- dim(fixedArray)[1]
	
	#get those who never reach thresh
	BEDH <- read.csv(file=fileName, head=TRUE, sep=" ")
	d<-as.data.frame(BEDH)
	d2 = d
	n <- dim(BEDH)[1] - 1
	nnu = d$ID[n]
	part1 = strsplit(fileFixedArray, "_")
	part2 = strsplit(part1[[1]][8], "S.")
	S = as.numeric(part2[[1]][2]) #get S from file input
	
	slowArray = array(dim=c(length(namesArray$V1),1))
		for (k in c(1:length(namesArray$V1))) {
			d <- as.data.frame(BEDH)
			d2 = d
			timeDiff <- array();
			for (j in c(1:nnu)) {
				lastIndex <- dim(d[d$ID == j,])[1]
				timeDiff[j] <- d[d$ID == j,][lastIndex,2] - d[d$ID == j,][1,2]				
				if ((dim(d[d$ID == j & d$OD > namesArray$V1[k],])[1] == 0) & timeDiff[j] < Wmax) {
						d2[d2$ID == j,][2] <- 22222
						d2[d2$ID == j,][3] <- 22222
				}
			}
			
			for (j in c(1:nnu)) {
				if (dim(d[d$ID == j,])[1] < S) {
					d2[d2$ID == j,][2] <- 33333
					d2[d2$ID == j,][3] <- 33333
				}
			}
			
			d3 <- d2[d2$OD != 33333,]
			numbers <- which(d3$OD == 22222)
			slowArray[k] = length(unique(d3$ID[numbers]))
	}

	
	
	for (j in c(loopStart:loopLimit)) {
		sasOut[[j]] <- read.table(file = paste(fileReadLocation, fileRandomArray, "_OD.", namesArray$V1[j], ".csv", sep=""), head=TRUE, sep=",")
		k <- 1
		l <- 1
		uTemp <- array()
		lTemp <- array()
		len <- dim(sasOut[[j]])[1]
		lenArray[[j]] = len
		while (k < len) {
			uTemp[l] = exp((sqrt(namesArray$V1[j])- fixedArray[j,1] - sasOut[[j]][k,3])/(fixedArray[j,2] + sasOut[[j]][k+1,3]))
			lTemp[l] = exp((sqrt(ODL)- fixedArray[j,1] - sasOut[[j]][k,3])/(fixedArray[j,2] + sasOut[[j]][k+1,3]))
			k <- k + 2
			l <- l + 1
		}

		lower[[j]] <- lTemp;
		upper[[j]] <- uTemp
		tempDiff[[j]] = uTemp - lTemp + 25
		tempDiffY365tmp = tempDiff[[j]]
		count365[[j]] = length(tempDiffY365tmp[tempDiffY365tmp < Wmax])
		tempDiffY365tmp[tempDiffY365tmp > Wmax] = Wmax # added on 16.08.2011
		tempDiffY365[[j]] = tempDiffY365tmp
		
		addOnArray <- array(dim=c(slowArray[j],1))	# set array to be size of those who remain under C
		addOnArray[] <- Wmax # set those under C to have a window of Wmax (usually 365 days)
		addonArrayList[[j]] <- addOnArray
		tempDiffY365sp[[j]] <- c(tempDiffY365[[j]], addOnArray)
		
		#compute boot means for normal array and array with slow progressors included
		CI[[j]] <- bootMean(tempDiffY365[[j]]) #
		CIsp[[j]] <- bootMean(tempDiffY365sp[[j]])
		
		# write file of individual means
		CIout[j] <- paste(namesArray$V1[j], CI[[j]][3], (CI[[j]][3] - CI[[j]][1]), ((CI[[j]][2] - CI[[j]][3])), CIsp[[j]][5], length(lower[[j]]), sep=" ")
		CIoutsp[j] <- paste(namesArray$V1[j], CIsp[[j]][3], (CIsp[[j]][3] - CIsp[[j]][1]), ((CIsp[[j]][2] - CIsp[[j]][3])), CIsp[[j]][5], length(tempDiffY365sp[[j]]), sep=" ")
		write.table(tempDiffY365[[j]], file = paste(fileReadLocation, fileRandomArray,".indmean",namesArray$V1[j], ".csv", sep=""), sep = " ", col.names = FALSE, append="FALSE", row.names=FALSE, quote=FALSE)

	}
	
		#write mean and CI to csv file
		headings = paste("OD", "Mean_R", "-", "+", "stdERR","N", sep = " ")
		write.table(headings, file = paste(fileReadLocation, fileRandomArray,".mean.csv", sep=""), sep = " ", col.names = FALSE, append="FALSE", row.names=FALSE, quote=FALSE)
		write.table(CIout, file = paste(fileReadLocation, fileRandomArray,".mean.csv", sep=""), sep = " ", col.names = FALSE, append="TRUE", row.names=FALSE, quote=FALSE)
	
		#write slow progressor modified thingy
		write.table(headings, file = paste(fileReadLocation, fileRandomArray,".meansp.csv", sep=""), sep = " ", col.names = FALSE, append="FALSE", row.names=FALSE, quote=FALSE)
		write.table(CIoutsp, file = paste(fileReadLocation, fileRandomArray,".meansp.csv", sep=""), sep = " ", col.names = FALSE, append="TRUE", row.names=FALSE, quote=FALSE)
	
	
	# <-------------------------------------------------End code ----------------------------------------------------------------------------------------->
